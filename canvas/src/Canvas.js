import { ImageLoader } from "./ImageLoader";

export default class Canvas {
  static canvas = document.querySelector("#canvas-root canvas");
  static canvasRoot = document.querySelector("#canvas-root");
  static ctx;
  static defaultCanvasSize = {
    w: 600,
    h: 600,
  };

  // p5.jsを使用している場合はインスタンスの参照を保持する
  static p5Instance = null;

  static currentLoopAnimationID = 0;
  static events = [];
  static eventsCanvas = [];
  static isTouchDevice = "ontouchend" in document;
  static deviceTrigger = () => ({
    start: Canvas.isTouchDevice ? "touchstart" : "mousedown",
    end: Canvas.isTouchDevice ? "touchend" : "mouseup",
  });
  static getTouchPosition = (e) => ({
    x: Canvas.isTouchDevice ? e.changedTouches[0].pageX : e.pageX,
    y: Canvas.isTouchDevice ? e.changedTouches[0].pageY : e.pageY,
  });
  static requestAnimFrame = () =>
    window.requestAnimationFrame ||
    window.webkitRequestAnimationFrame ||
    ((callback) => window.setTimeout(callback, 1000 / 60));
  static cancelCurrentCommand() {
    cancelAnimationFrame(this.currentLoopAnimationID);
    this.currentLoopAnimationID = 0;
  }

  /**
   * p5.jsを使用している場合はインスタンスの参照を保持する
   * @param {*} p
   * @returns
   */
  static setP5Instance = (p) => {
    if (!p || !p.hasOwnProperty("setup")) {
      return;
    }
    Canvas.p5Instance = p;
  };

  /**
   * p5.jsのループを停止しインスタンスの参照を削除する
   */
  static removeP5Instance = () => {
    if (Canvas.p5Instance) {
      Canvas.p5Instance.remove();
      Canvas.p5Instance = null;
    }
  };
  static imageLoader = new ImageLoader();

  static waitResolveImgs = async () =>
    await Canvas.imageLoader.waitResolveImgs();
  static createImg = (path) => Canvas.imageLoader.createImg(path);

  static removeCanvas = () => {
    Canvas.removeP5Instance();
    /* p5.jsでCreateCanvasするとインラインにstyleの
     * widthが強制的に書かれて他の関数実行に影響を及ぼすため
     * canvasごと削除するのが合理的 */
    if (Canvas.canvas) {
      Canvas.canvas.remove();
      Canvas.canvas = null;
    }
  };

  static setCanvas = (
    w,
    h,
    renderer = '2d'
  ) => {
    w = w || Canvas.defaultCanvasSize.w
    h = h || Canvas.defaultCanvasSize.h
    if (!Canvas.canvas) {
      // Canvasを新規作成
      Canvas.canvas = document.createElement("canvas");
      Canvas.canvasRoot.appendChild(Canvas.canvas);
    }
    Canvas.ctx = Canvas.canvas.getContext(renderer);
    Canvas.canvas.width = w;
    Canvas.canvas.height = h;
  };

  static cancelLoop = () => {
    if (Canvas.currentLoopAnimationID)
      cancelAnimationFrame(Canvas.currentLoopAnimationID);
  };

  // Wrapper func for loop animation
  static loop = (f) => {
    Canvas.cancelLoop();

    const repeat = () => {
      Canvas.currentLoopAnimationID = Canvas.requestAnimFrame()(repeat);
      f();
    };

    Canvas.currentLoopAnimationID = Canvas.requestAnimFrame()(repeat);
  };

  // Add event listner
  static addWindowEvent = (type, func, options = null) => {
    Canvas.events.push([type, func]);
    window.addEventListener(type, func, options);
  };

  static removeEvents = () => {
    for (let e of Canvas.events) {
      window.removeEventListener(e[0], e[1]);
    }
  };

  static registerCanvasEvent = (type, func, options = null) => {
    Canvas.eventsCanvas.push([type, func]);
    Canvas.canvas.addEventListener(type, func, options);
  };

  static removeCanvasEvents = () => {
    for (let e of Canvas.eventsCanvas) {
      Canvas.canvas.removeEventListener(e[0], e[1]);
    }
  };

  static drawBG = (color, clear = true) => {
    const canvas = Canvas.ctx.canvas;
    const clearBG = () =>
      Canvas.ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (clear) clearBG();
    Canvas.ctx.fillStyle = color;
    Canvas.ctx.fillRect(0, 0, canvas.width, canvas.height);
  };
  static drawArc = (x, y, r, color) => {
    const context = Canvas.ctx;
    context.beginPath();
    context.arc(x, y, r, 0, Math.PI * 2);
    context.closePath();
    context.fillStyle = color;
    context.fill();
  };

  static drawRect = (x, y, w, h, color) => {
    const context = Canvas.ctx;
    context.beginPath();
    context.rect(x, y, w, h);
    context.closePath();
    context.fillStyle = color;
    context.fill();
  };

  static drawText = (text, x, y, color) => {
    const context = Canvas.ctx;
    context.fillStyle = color;
    context.fillText(text, x, y);
  };

  static measureText = (text) => Canvas.ctx.measureText(text).width;

  static moveParticle = (O) => (size) => (col) => (V) => {
    O.x += V.x;
    O.y += V.y;
    return [O.x, O.y, size, col];
  };

  static moveObj = (O) => (Size) => (V) => {
    O.x += V.x;
    O.y += V.y;
    return { x: O.x, y: O.y, w: Size.w, h: Size.h };
  };
  static randomColor = () => Math.random() * 255;

  static randomRGBA = (opacity) =>
    `rgba(${Canvas.randomColor()},${Canvas.randomColor()},${Canvas.randomColor()}, ${opacity})`;
  // Parse a json file generated by Aseprite
  //   Default: create each frame as a object, and generate a array with all frames.
  static parseAsperiteJSON = (data, toArray = false) =>
    parseAsperiteJSON(data, toArray);

  static drawImage = (source, inputFrame, outputImage = inputFrame) => {
    Canvas.ctx.drawImage(
      source,
      ...[inputFrame.x, inputFrame.y, inputFrame.w, inputFrame.h],
      ...[outputImage.x, outputImage.y, outputImage.w, outputImage.h]
    );
  };

  // how to flip image: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/scale
  static flipImage = (image) => {
    const canv = document.createElement("canvas");
    const ctx = canv.getContext("2d");
    const newImage = new Image();
    canv.width = image.width;
    canv.height = image.height;

    if (!ctx) return;
    ctx.scale(-1, 1);
    ctx.drawImage(image, -image.width, 0);
    newImage.src = canv.toDataURL();
    return newImage;
  };

  static fitBackgroundScale = (imgOriginalWidth, maxScale) => {
    const context = Canvas.ctx;
    const canvas = context.canvas;
    const cw = canvas.width;
    const x =
      cw / imgOriginalWidth <= maxScale ? cw / imgOriginalWidth : maxScale;
    const y = x;
    context.scale(x, y);
    return [x, y];
  };

  static frameCalc =
    (framesData, frameLength, speed, head, reverse = false) =>
    (tick) =>
      frameCalc(framesData, frameLength, speed, head, reverse)(tick);

}

// TODO: Asepriteパース用クラスを新規作成
// 画像とJSONを保持する一つのオブジェクトを作る
function parseAsperiteJSON(data, toArray = false) {
  const frames = data.frames;
  let ary = [];
  const frametoary = (frameObj) => [
    frameObj.x,
    frameObj.y,
    frameObj.w,
    frameObj.h,
  ];
  for (let key of Object.keys(frames)) {
    let eachFrame = frames[key].frame;
    if (toArray) eachFrame = frametoary(eachFrame);
    ary.push(eachFrame);
  }
  return ary;
}

const frameCalc =
  (framesData, frameLength, speed, head, reverse = false) =>
  (tick) => {
    const current = tick % (frameLength * speed);
    for (let i = 0; i < frameLength; i++) {
      const currentFrame = reverse ? head - i : head + i;
      if (current < (i + 1) * speed) return framesData[currentFrame];
    }
  };
