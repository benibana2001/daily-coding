import { ImageLoader } from "./ImageLoader";

export default class Canvas {
  static canvas = document.querySelector("#canvas-root canvas");
  static canvasRoot = document.querySelector("#canvas-root");
  static ctx;
  static defaultCanvasSize = {
    w: 600,
    h: 600,
  };
  static currentLoopAnimationID = 0;
  static events = [];
  static eventsCanvas = [];
  static requestAnimFrame = () =>
    window.requestAnimationFrame ||
    window.webkitRequestAnimationFrame ||
    ((callback) => window.setTimeout(callback, 1000 / 60));

  static cancelCurrentCommand() {
    cancelAnimationFrame(this.currentLoopAnimationID);
    this.currentLoopAnimationID = 0;
  }
  static imageLoader = new ImageLoader();

  static waitResolveImgs = async () => await Canvas.imageLoader.waitResolveImgs();
  static createImg = (path) => Canvas.imageLoader.createImg(path);

  static removeCanvas = () => {
    /* p5.jsでCreateCanvasするとインラインにstyleの
     * widthが強制的に書かれて他の関数実行に影響を及ぼすため
     * canvasごと削除するのが合理的 */
    if (Canvas.canvas) {
      Canvas.canvas.remove();
      Canvas.canvas = null;
    }
  };

  static setCanvas = (
    w = Canvas.defaultCanvasSize.w,
    h = Canvas.defaultCanvasSize.h
  ) => {
    if (!Canvas.canvas) {// Canvasを新規作成
      Canvas.canvas = document.createElement("canvas");
      Canvas.canvasRoot.appendChild(Canvas.canvas);
    }
    Canvas.ctx = Canvas.canvas.getContext("2d");
    Canvas.canvas.width = w;
    Canvas.canvas.height = h;
  };

  static cancelLoop = () => {
    if (Canvas.currentLoopAnimationID)
      cancelAnimationFrame(Canvas.currentLoopAnimationID);
  };

  // Wrapper func for loop animation
  static loop = (f) => {
    Canvas.cancelLoop();

    const repeat = () => {
      Canvas.currentLoopAnimationID = Canvas.requestAnimFrame()(repeat);
      f();
    };

    Canvas.currentLoopAnimationID = Canvas.requestAnimFrame()(repeat);
  };

  // Add event listner
  static registerEvent = (type, func, options = null) => {
    Canvas.events.push([type, func]);
    window.addEventListener(type, func, options);
  };
  static removeEvents = () => {
    for (let e of Canvas.events) {
      window.removeEventListener(e[0], e[1]);
    }
  };

  static registerCanvasEvent = (type, func, options = null) => {
    Canvas.eventsCanvas.push([type, func]);
    Canvas.canvas.addEventListener(type, func, options);
  };

  static removeCanvasEvents = () => {
    for (let e of Canvas.eventsCanvas) {
      Canvas.canvas.removeEventListener(e[0], e[1]);
    }
  };

  static drawBG = (color, clear = true) => {
    const canvas = Canvas.ctx.canvas;
    const clearBG = () => Canvas.ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (clear) clearBG();
    Canvas.ctx.fillStyle = color;
    Canvas.ctx.fillRect(0, 0, canvas.width, canvas.height);
  };
  static drawArc = (x, y, r, color) => {
    const context = Canvas.ctx;
    context.beginPath();
    context.arc(x, y, r, 0, Math.PI * 2);
    context.closePath();
    context.fillStyle = color;
    context.fill();
  };

  static drawRect = (x, y, w, h, color) => {
    const context = Canvas.ctx;
    context.beginPath();
    context.rect(x, y, w, h);
    context.closePath();
    context.fillStyle = color;
    context.fill();
  };

  static drawText = (text, x, y, color) => {
    const context = Canvas.ctx;
    context.fillStyle = color;
    context.fillText(text, x, y);
  };

  static measureText = (text) => Canvas.ctx.measureText(text).width;

  static moveParticle = (O) => (size) => (col) => (V) => {
    O.x += V.x;
    O.y += V.y;
    return [O.x, O.y, size, col];
  };

  static moveObj = (O) => (Size) => (V) => {
    O.x += V.x;
    O.y += V.y;
    return { x: O.x, y: O.y, w: Size.w, h: Size.h };
  };
  static randomColor = () => Math.random() * 255;

  static randomRGBA = (opacity) =>
    `rgba(${Canvas.randomColor()},${Canvas.randomColor()},${Canvas.randomColor()}, ${opacity})`;
  // Parse a json file generated by Aseprite
  //   Default: create each frame as a object, and generate a array with all frames.
  static parseAsperiteJSON = (data, toArray = false) =>
    parseAsperiteJSON(data, toArray);

  static drawImage = (source, inputFrame, outputImage = inputFrame) => {
    Canvas.ctx.drawImage(
      source,
      ...[inputFrame.x, inputFrame.y, inputFrame.w, inputFrame.h],
      ...[outputImage.x, outputImage.y, outputImage.w, outputImage.h]
    );
  };

  // how to flip image: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/scale
  static flipImage = (image) => {
    const canv = document.createElement("canvas");
    const ctx = canv.getContext("2d");
    const newImage = new Image();
    canv.width = image.width;
    canv.height = image.height;

    if (!ctx) return;
    ctx.scale(-1, 1);
    ctx.drawImage(image, -image.width, 0);
    newImage.src = canv.toDataURL();
    return newImage;
  };

  static fitBackgroundScale = (imgOriginalWidth, maxScale) => {
    const context = Canvas.ctx;
    const canvas = context.canvas;
    const cw = canvas.width;
    const x =
      cw / imgOriginalWidth <= maxScale ? cw / imgOriginalWidth : maxScale;
    const y = x;
    context.scale(x, y);
    return [x, y];
  };

  static frameCalc =
    (framesData, frameLength, speed, head, reverse = false) =>
    (tick) =>
      frameCalc(framesData, frameLength, speed, head, reverse)(tick);

  static deviceTrigger = () => deviceTrigger();
  static getTouchPosition = (e) => getTouchPosition(e);
}

function parseAsperiteJSON(data, toArray = false) {
  const frames = data.frames;
  let ary = [];
  const frametoary = (frameObj) => [
    frameObj.x,
    frameObj.y,
    frameObj.w,
    frameObj.h,
  ];
  for (let key of Object.keys(frames)) {
    let eachFrame = frames[key].frame;
    if (toArray) eachFrame = frametoary(eachFrame);
    ary.push(eachFrame);
  }
  return ary;
}

// TODO: Aseprite の関数群として一つにまとめるか
const frameCalc =
  (framesData, frameLength, speed, head, reverse = false) =>
  (tick) => {
    const current = tick % (frameLength * speed);
    for (let i = 0; i < frameLength; i++) {
      const currentFrame = reverse ? head - i : head + i;
      if (current < (i + 1) * speed) return framesData[currentFrame];
    }
  };

const deviceTrigger = () => ({
  start: isTouchDevice ? "touchstart" : "mousedown",
  end: isTouchDevice ? "touchend" : "mouseup",
});

const getTouchPosition = (e) => ({
  x: isTouchDevice ? e.changedTouches[0].pageX : e.pageX,
  y: isTouchDevice ? e.changedTouches[0].pageY : e.pageY,
});

const isTouchDevice = "ontouchend" in document;
